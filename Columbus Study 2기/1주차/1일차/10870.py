# https://www.acmicpc.net/problem/10870
# 문제 설명: n번째 피보나치 수를 출력
# 핵심 개념: 동적 계획법(Dynamic Programming) 중 메모이제이션(Memoization) 기법을 사용한 피보나치 수열 계산.
# 메모이제이션 사용 조건: 계산된 결과를 저장할 공간이 필요하며, 이미 계산된 값을 재활용하여 중복 계산을 줄이고자 할 때 사용합니다.
# 이 문제에서는 피보나치 수열의 각 항을 계산할 때 이미 계산된 항의 값은 배열에 저장하여 재사용함으로써 효율성을 높입니다.
# 시간 복잡도: O(N), 여기서 N은 입력받은 피보나치 수열의 항 번호입니다.
# 각 항을 계산하기 위해 최대 한 번씩만 계산을 수행하므로, N에 대해 선형 시간 복잡도를 가집니다.

data = [0]*21  # 계산된 피보나치 수를 저장할 배열, 문제 조건에 따라 크기는 적절히 조정 가능


def fibo(k):
    # 기저 사례 처리: 0번째 피보나치 수는 0, 1번째 및 2번째는 1
    if k == 0:
        return 0
    if k == 1 or k == 2:
        data[k] = 1
        return data[k]
    # 이미 계산된 값이 있으면 그 값을 반환
    if data[k] != 0:
        return data[k]
    # 재귀적으로 k-1번째와 k-2번째 피보나치 수의 합을 계산하여 k번째 값을 구함
    data[k] = fibo(k-1) + fibo(k-2)
    return data[k]


n = int(input())  # 사용자로부터 n 입력 받음
print(fibo(n))  # n번째 피보나치 수 출력
